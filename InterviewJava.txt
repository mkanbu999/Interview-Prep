1.
A programming paradigm is a fundamental style or approach to writing software. It defines the way in which a programmer thinks about the problem they are trying to solve, and the way in which they express the solution using the programming language.

There are several different programming paradigms, including:

Imperative programming, which focuses on describing a series of steps or operations that a computer should perform to achieve a specific task.
Object-oriented programming, which focuses on modeling software as a collection of interacting objects, each of which represents an instance of a class.
Functional programming, which emphasizes the use of pure functions, immutability, and the avoidance of side effects.
Logical programming, which focuses on representing knowledge and solving problems using logic and logical reasoning.
Procedural programming, which focuses on breaking a problem down into a series of procedures or functions that are called in a specific order to solve the problem.
Each programming paradigm has its own strengths and weaknesses and is better suited to certain types of problems than others. A programmer may choose to use a specific paradigm based on their personal preference, the problem they are trying to solve, or the constraints of the project.


======================================================================================================================================================
2.
Imperative programming in Java is a way of writing code that focuses on describing the steps or operations that a computer should perform to achieve a specific task. It uses statements that change the state of the program and variables can be modified.

Functional programming in Java is a way of writing code that emphasizes the use of pure functions and immutability, it encourages the use of functional constructs like lambda expressions and function composition. The state of the program is not allowed to change and variables are immutable.

In simple words, imperative programming is like giving the computer a set of instructions on what to do, step by step. While functional programming is like giving the computer a set of rules to follow without changing the state of the program.


Imperative Programming:

public static int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

public static void main(String[] args) {
    System.out.println(factorial(5)); // 120
}



Functional Programming:

import java.util.stream.IntStream;

public static int factorial(int n) {
    return IntStream.rangeClosed(1, n)
                    .reduce(1, (x, y) -> x * y);
}

public static void main(String[] args) {
    System.out.println(factorial(5)); // 120
}


======================================================================================================================================================
3.
lambda expression

In Java, lambda expressions are used to define a function that can be passed as an argument to a method or assigned to a variable. They are a concise way of defining a function without having to create a separate class or method.

Here's an example of using a lambda expression in a Java program:


import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        // Define a lambda expression that takes a string and returns its length
        Function<String, Integer> getStringLength = (string) -> string.length();

        // Use the lambda expression
        int length = getStringLength.apply("Hello");
        System.out.println("Length: " + length);
    }
}


In this example, the lambda expression (string) -> string.length() is assigned to a variable of type Function<String, Integer>, which is a functional interface that takes a string and returns an integer. The lambda expression is then used to calculate the length of a string.

Lambda expressions can also be used with other functional interfaces from the java.util.function package, such as Consumer, Predicate, and Supplier, which allow you to perform operations on input, make decisions based on input, and get a value respectively.

Lambda expressions are also used with Stream API, which was introduced in Java 8. It allows to process collections of data in a functional way, by performing operations such as filtering, mapping, and reducing on a stream of elements.



Here are some benefits of using lambda expressions in Java:

Conciseness: Lambda expressions allow you to express a function in a compact and readable form, without having to create a separate class or method. This can make your code more concise and easier to understand.

Increased readability: Because lambda expressions are more concise than traditional anonymous classes, they can make your code more readable and reduce the amount of clutter.

Improved maintainability: Lambda expressions can make your code more maintainable by reducing the amount of boilerplate code and increasing the level of abstraction.

Increased flexibility: Lambda expressions can be used in a variety of situations, such as passing a function as an argument to a method, returning a function as a value, or assigning a function to a variable.

Improved performance: The use of lambda expressions with the Stream API, can improve performance by allowing operations to be performed in parallel on large collections of data.

Functional programming: Lambda expressions are an important part of functional programming, it allows to create more expressive and elegant code with fewer lines of code.

In short, lambda expressions provide a more concise and readable way of defining a function, they can be used in a variety of situations, and can make your code more maintainable and performant.

======================================================================================================================================================
4.Inner classes in Java

There are four types of inner classes in Java:
Member Inner Class
Local Inner Class:
Anonymous Inner Class
Static Inner Class

Member Inner Class: A member inner class is defined inside another class, and it has access to all of the members of the outer class, including private members.
// Java Program to Demonstrate Nested class 
 
// Class 1
// Helper classes
class Outer {
 
    // Class 2
    // Simple nested inner class
    class Inner {
 
        // show() method of inner class
        public void show()
        {
 
            // Print statement
            System.out.println("In a nested class method");
        }
    }
}
 
// Class 2
// Main class
class Main {
 
    // Main driver method
    public static void main(String[] args)
    {
 
        // Note how inner class object is created inside
        // main()
        Outer.Inner in = new Outer().new Inner();
 
        // Calling show() method over above object created
        in.show();
    }
}



We can not have a static method in a nested inner class because an inner class is implicitly associated with an object of its outer class so it cannot define any static method for itself. For example, the following program doesnâ€™t compile. But Since JAVA Version 16 we can have static members in our inner class also.
// Class 1
// Outer class
class Outer {
 
    // Method defined inside outer class
    void outerMethod()
    {
 
        // Print statement
        System.out.println("inside outerMethod");
    }
 
    // Class 2
    // Inner class
    class Inner {
 
        // Main driver method
        public static void main(String[] args)
        {
 
            // Display message for better readability
            System.out.println("inside inner class Method");
        }
    }
}

------------------------------------------------------------------------------------------------------

Local Inner Class: A local inner class is defined inside a method, and it has access to all of the members of the outer class, including private members.

class Outer {
   void outerMethod() {
      final int x=98;
      System.out.println("inside outerMethod");
      class Inner {
         void innerMethod() {
            System.out.println("x = "+x);
         }
      }
      Inner y = new Inner();
      y.innerMethod();
   }
}
class MethodLocalVariableDemo {
    public static void main(String[] args){
      Outer x = new Outer();
      x.outerMethod();
    }
}



// declared within a method of outer class
 
// Class 1
// Outer class
class Outer {
 
    // Method inside outer class
    void outerMethod()
    {
 
        // Print statement
        System.out.println("inside outerMethod");
 
        // Class 2
        // Inner class
        // It is local to outerMethod()
        class Inner {
 
            // Method defined inside inner class
            void innerMethod()
            {
 
                // Print statement whenever inner class is
                // called
                System.out.println("inside innerMethod");
            }
        }
 
        // Creating object of inner class
        Inner y = new Inner();
 
        // Calling over method defined inside it
        y.innerMethod();
    }
}
 
// Class 3
// Main class
class GFG {
 
    // Main driver method
    public static void main(String[] args)
    {
 
        // Creating object of outer class inside main()
        // method
        Outer x = new Outer();
 
        // Calling over the same method
        // as we did for inner class above
        x.outerMethod();
    }
}


----------------------------------------------------------------------------------------------------------------


Anonymous Inner Class: An anonymous inner class is defined and instantiated in a single statement, and it cannot have a name. It's commonly used as a method argument.

Anonymous inner classes are declared without any name at all. They are created in two ways. 

As a subclass of the specified type
As an implementer of the specified interface


// Declaration Without any Name 
// As a subclass of the specified type
 
// Importing required classes
import java.util.*;
 
// Class 1
// Helper class
class Demo {
 
    // Method of helper class
    void show()
    {
        // Print statement
        System.out.println(
            "i am in show method of super class");
    }
}
 
// Class 2
// Main class
class Flavor1Demo {
 
    //  An anonymous class with Demo as base class
    static Demo d = new Demo() {
        // Method 1
        // show() method
        void show()
        {
            // Calling method show() via super keyword
            // which refers to parent class
            super.show();
 
            // Print statement
            System.out.println("i am in Flavor1Demo class");
        }
    };
 
    // Method 2
    // Main driver method
    public static void main(String[] args)
    {
        // Calling show() method inside main() method
        d.show();
    }
}




// Declaration Without Any Name
// As an implementer of Specified interface
 
// Interface
interface Hello {
 
    // Method defined inside interface
    void show();
}
 
// Main class
class GFG {
 
    // Class implementing interface
    static Hello h = new Hello() {
       
        // Method 1
        // show() method inside main class
        public void show()
        {
            // Print statement
            System.out.println("i am in anonymous class");
        }
    };
 
    // Method 2
    // Main driver method
    public static void main(String[] args)
    {
        // Calling show() method inside main() method
        h.show();
    }
}





----------------------------------------------------------------------------------------------------------------

Static Inner Class: A static inner class is defined inside another class, but it does not have access to the instance variables of the outer class. It can be used as a top-level class.
Static nested classes are not technically inner classes. They are like a static member of outer class. 


// Importing required classes
import java.util.*;
 
// Class 1
// Outer class
class Outer {
 
    // Method
    private static void outerMethod()
    {
 
        // Print statement
        System.out.println("inside outerMethod");
    }
 
    // Class 2
    // Static inner class
    static class Inner {
 
        public static void display()
        {
 
            // Print statement
            System.out.println("inside inner class Method");
 
            // Calling method inside main() method
            outerMethod();
        }
    }
}
 
// Class 3
// Main class
class GFG {
 
    // Main driver method
    public static void main(String args[])
    {
 
        // Calling method static display method rather than an instance of that class.
        Outer.Inner.display();
    }
}
}

There are certain advantages associated with inner classes are as follows:

Making code clean and readable.
Private methods of the outer class can be accessed, so bringing a new dimension and making it closer to the real world.
Optimizing the code module.

================================================================================================================================================================

5.comparator

A comparator in Java is an interface (java.util.Comparator) that defines a method int compare(T o1, T o2) which compares two objects of the same type and returns an integer value indicating their order. The comparator is used to sort a collection of objects in a custom order defined by the implementer of the interface.

On the other hand, Comparator is a separate class that implements the Comparator interface, and it allows you to define multiple different sort orders for the same type of objects. For example, you can create one Comparator class(CompareStrudentAge) to sort Person objects based on their age and another Comparator(CompareStrudentName) class to sort Person objects based on their name.(refer given ex below)

Here is an example of a comparator that compares two strings based on their length:

import java.util.Comparator;

public class StringLengthComparator implements Comparator<String> {
  @Override
  public int compare(String s1, String s2) {
    return Integer.compare(s1.length(), s2.length());
  }
}

This comparator can be used to sort a list of strings in ascending order of their length, like this:

List<String> list = Arrays.asList("dog", "cat", "elephant", "giraffe");
Collections.sort(list, new StringLengthComparator());
System.out.println(list);

This will print [dog, cat, giraffe, elephant]

-------------------------------------------------------------------------------------------------
another ex:

import java.util.Comparator;

public class Employee {
  private String name;
  private double salary;

  public Employee(String name, double salary) {
    this.name = name;
    this.salary = salary;
  }

  public String getName() {
    return name;
  }

  public double getSalary() {
    return salary;
  }

  @Override
  public String toString() {
    return name + ": $" + salary;
  }
}

public class EmployeeSalaryComparator implements Comparator<Employee> {
  @Override
  public int compare(Employee e1, Employee e2) {
    return Double.compare(e1.getSalary(), e2.getSalary());
  }
}


List<Employee> employees = Arrays.asList(
    new Employee("John Doe", 75000),
    new Employee("Jane Doe", 80000),
    new Employee("Bob Smith", 65000)
);
Collections.sort(employees, new EmployeeSalaryComparator());
System.out.println(employees);


This will print [Bob Smith: $65000.0, John Doe: $75000.0, Jane Doe: $80000.0].
------------------------------------------------------------------------------------------------

package practiseJavaProb;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Main {
  public static void main(String[] args) {
    ArrayList<Student> students = new ArrayList<Student>();
    students.add(new Student("John", 20));
    students.add(new Student("Jane", 18));
    students.add(new Student("Bob", 22));
    
    Collections.sort(students, new StudentComparatorName());
	Collections.sort(students, new StudentComparatorAge());
    
    for (Student student : students) {
      System.out.println(student.getName());
    }
  }
}

class Student {
  private String name;
  private int age;
  
  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }
  
  public String getName() {
    return name;
  }
  
  public int getAge() {
    return age;
  }
}

class StudentComparatorName implements Comparator<Student> {
  public int compare(Student student1, Student student2) {
    return student1.getName().compareTo(student2.getName());
  }
}

class StudentComparatorAge implements Comparator<Student> {
  public int compare(Student student1, Student student2) {
     return student1.getAge() - student2.getAge();
  }
}

Bob
Jane
John
======================================================================================================================================================
6.comparable

Comparable is an interface used for sorting elements of the same type, and is defined in the java.lang package. The compareTo method of this interface compares the current object with the given object. If the current object is smaller, it returns a negative number, if it is equal, it returns zero, and if it is greater, it returns a positive number.


import java.util.ArrayList;
import java.util.Collections;

public class Main {
  public static void main(String[] args) {
    ArrayList<Student> students = new ArrayList<Student>();
    students.add(new Student("John", 20));
    students.add(new Student("Jane", 18));
    students.add(new Student("Bob", 22));
    
    Collections.sort(students);
    
    for (Student student : students) {
      System.out.println(student.getName());
    }
  }
}

class Student implements Comparable<Student> {
  private String name;
  private int age;
  
  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }
  
  public String getName() {
    return name;
  }
  
  public int getAge() {
    return age;
  }
  
  public int compareTo(Student other) {
    return this.age - other.age;
	//return this.name.compareTo(other.name);
  }
}

Jane
John
Bob

======================================================================================================================================================
7.Generics

Generics in Java are a feature that allows you to write type-safe and reusable code. With generics, you can define a class, interface, or method that can work with objects of any type. The type of objects the class, interface, or method can work with is specified as a parameter in angle brackets <>.




https://youtu.be/JY8-UMQ7vmY  (daily code buffer)

public class MyClass<T> {
  private T value;

  public MyClass(T value) {
    this.value = value;
  }

  public T getValue() {
    return value;
  }

  public void setValue(T value) {
    this.value = value;
  }
}


======================================================================================================================================================
8.

Collection

In java collection is a frameWork .Collection  stores group of object in it . it has readily
 available logic to deal or manupulate the different dataStructue. 
 
 The java.util package in Java contains several classes and interfaces that make up the Collection framework. These classes and interfaces provide a way to work with collections of objects. Here is a list of classes and interfaces:

Interfaces:

Collection
Deque
List
Queue
Set
SortedSet
Map
ConcurrentMap
SortedMap
NavigableMap
Map.Entry
Classes:

ArrayList
LinkedList
Vector
Stack
HashSet
LinkedHashSet
TreeSet
EnumSet
HashMap
LinkedHashMap
TreeMap
Hashtable
Properties
IdentityHashMap
WeakHashMap
EnumMap
AbstractMap
AbstractList
AbstractSequentialList
AbstractSet
AbstractCollection
These classes and interfaces provide a wide range of functionality for working with collections of objects in Java.


ArrayList

Internally its implemented as dynamic Array.Initial size of ArrayList is 10 when we exceed the 
 Initial size automattically Arraylist increases the size of 1.5 times.in ArrayList we dont need to use index no
 to insert data in obj by using add method.maintain insertion order can consist of duplicate value.
 if we takl about advantage reading of data would be give  best perfomence.but in writing suffiling will happen.
 its required continiues memory(array list implements List interface)
hold only non primitive.its not synchronised by default but we can make it synchronised  collection.synchonizeList().

//if  need to insertion and delete perform frequently where we can use linked list it give good perfomence.

ArrayList is a class in Java that implements the List interface and provides a dynamic array implementation of it. It allows you to store a collection of elements and provides various operations for adding, removing, and accessing elements.

Some of the key features of ArrayList are:

Dynamic size: The size of an ArrayList can grow or shrink dynamically as elements are added or removed.

Index-based access: You can access elements in an ArrayList using an index, which starts from 0.

Order preservation: The order of elements in an ArrayList is preserved and can be easily accessed in the same order they were added.

Type safety: ArrayList is a generic class and allows you to specify the type of elements it can store. This helps to ensure type safety and prevents errors related to type mismatch.

ArrayList in Java allows you to store duplicate elements. You can add multiple elements with the same value to an ArrayList, and it will keep all of them

ArrayList is that it maintains the insertion order of its elements, meaning that the order in which elements are added to the list is the same order in which they will be retrieved

Here's an example of how you can create an ArrayList and perform some basic operations with it:

import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {
    ArrayList<Integer> numbers = new ArrayList<Integer>();
    numbers.add(10);
    numbers.add(20);
    numbers.add(30);
    
    System.out.println("Size of the list: " + numbers.size());
    System.out.println("Element at index 1: " + numbers.get(1));
    
    numbers.remove(1);
    System.out.println("Size of the list after removing an element: " + numbers.size());
    
    for (Integer number : numbers) {
      System.out.println(number);
    }
  }
}
-----------------------------------------------------------------------------------------------------------

LinkedList
its stored group of object in it.
In LinkedList there is two type linkedList is there one singly linked list another type is doubly link list
its doesnt required continiues memory to store like arraylist.. insert and delete elements in the middle of the list relatively quickly
because its stored the value with next value memory address.

Dynamic size: LinkedList can dynamically grow or shrink in size as elements are added or removed.

Insertions and deletions: LinkedList provides efficient insertions and deletions at arbitrary positions compared to other linear data structures like arrays.

Traversal in both directions: LinkedList provides the advantage of a doubly linked list data structure, allowing for efficient traversal in both forward and backward directions.

Memory usage: LinkedList has a lower memory overhead compared to arrays as it only requires the memory for the element data and references to the previous and next elements.

In summary, LinkedList is a useful data structure for applications that require efficient insertions and deletions at arbitrary positions and when memory usage is a concern.
LinkedList is generally slower for reading elements compared to ArrayList because of its underlying data structure. In a LinkedList, each element is stored as a separate object with a reference to the previous and next element, so in order to access an element, the system must traverse the list of elements starting from the first element until it reaches the desired element. This results in a time complexity of O(n) for accessing an element, where n is the number of elements in the list.

import java.util.LinkedList;

public class LinkedListExample {
    public static void main(String[] args) {
        // Create a linked list
        LinkedList<String> ll = new LinkedList<>();

        // Add elements to the linked list
        ll.add("Apple");
        ll.add("Banana");
        ll.add("Carrot");

        // Print the linked list
        System.out.println("Linked List: " + ll);

        // Insert an element at the beginning of the linked list
        ll.addFirst("Cherry");
        System.out.println("Linked List after adding at the beginning: " + ll);

        // Insert an element at the end of the linked list
        ll.addLast("Date");
        System.out.println("Linked List after adding at the end: " + ll);

        // Insert an element at a specified position
        ll.add(3, "Eggplant");
        System.out.println("Linked List after adding at position 3: " + ll);

        // Remove the first element of the linked list
        ll.removeFirst();
        System.out.println("Linked List after removing the first element: " + ll);

        // Remove the last element of the linked list
        ll.removeLast();
        System.out.println("Linked List after removing the last element: " + ll);

        // Remove an element at a specified position
        ll.remove(2);
        System.out.println("Linked List after removing element at position 2: " + ll);
    }
}

Singly Linked List: In a singly linked list, each element (node) has a reference to the next element in the list, but not to the previous element. This type of linked list is used when you need to maintain a linear sequence of elements and only need to traverse the list in one direction.

Doubly Linked List: In a doubly linked list, each element (node) has a reference to both the previous and next elements in the list. This type of linked list is used when you need to traverse the list in both directions, and also provides faster access to elements compared to a singly linked list.

memmory concern we use any of them



--------------------------------------------------------------------------------------------------------------
When to use ArrayList:

 In a linked list, each element is stored as an individual object with a reference to the previous and next element, and in order to retrieve an element at a specific index, the linked list must be traversed from the beginning or end to find the desired element. This can be time-consuming and results in slower read performance compared to an array-based data structure like ArrayList.

On the other hand, adding or removing elements from a LinkedList is faster than adding or removing elements from an ArrayList. This is because an ArrayList requires shifting elements over to make room for new elements or filling the gap left by removed elements, while a LinkedList only requires updating the references to the previous and next elements.no suffiling

In an ArrayList, elements are stored in contiguous memory locations, and the index of each element is used to directly access the element in memory. This means that when reading an element from an ArrayList, the desired element can be directly accessed without the need to traverse through the entire list



---------------------------------------------------------------------------------------------------------------

Set

its an interface.it can store only unique value only and its not follow insertion order

note:
The order of elements matters in some data structures because it affects the way the elements are stored, retrieved, and manipulated, and this in turn can determine the time and space complexity of operations on the data structure. For example, in an array or a linked list, the order of elements determines their relative positions and impacts the time it takes to search for an element or insert a new one. In a data structure like a hash table, the order of elements is not guaranteed and may change over time, but the operations on the data structure are optimized for fast access and insertion based on the hash values of the elements.

In algorithms and programming, the order of elements can also affect the output and performance of operations, such as sorting, searching, and manipulating elements. For example, in sorting algorithms, the order of elements determines the final sorted output, and different sorting algorithms have different time and space complexities based on the order of elements.

Therefore, it is important to choose the appropriate data structure and to understand the implications of the order of elements when designing and implementing algorithms.


HashSet: a hash table-based implementation that does not maintain the order of elements and offers fast add, remove, and contains operations with average time complexity O(1).

import java.util.HashSet;

public class Main {
  public static void main(String[] args) {
    HashSet<Integer> set = new HashSet<>();
    set.add(1);
    set.add(2);
    set.add(3);
    System.out.println(set); // [1, 2, 3]
    set.remove(2);
    System.out.println(set); // [1, 3]
    System.out.println(set.contains(3)); // true
  }
}

TreeSet: a sorted set implementation based on a tree data structure. It maintains the order of elements and offers fast add, remove, and contains operations with average time complexity O(log n).

import java.util.TreeSet;

public class Main {
  public static void main(String[] args) {
    TreeSet<Integer> set = new TreeSet<>();
    set.add(3);
    set.add(1);
    set.add(2);
    System.out.println(set); // [1, 2, 3]
    set.remove(2);
    System.out.println(set); // [1, 3]
    System.out.println(set.contains(3)); // true
  }
}


LinkedHashSet: a hash table-based implementation that maintains the order of elements in which they were inserted. It offers fast add, remove, and contains operations with average time complexity O(1).

import java.util.LinkedHashSet;

public class Main {
  public static void main(String[] args) {
    LinkedHashSet<Integer> set = new LinkedHashSet<>();
    set.add(1);
    set.add(2);
    set.add(3);
    System.out.println(set); // [1, 2, 3]
    set.remove(2);
    System.out.println(set); // [1, 3]
    System.out.println(set.contains(3)); // true
  }
}


Here is a brief comparison of the three main Set implementations in Java:

HashSet:

Does not maintain the order of elements.
Offers fast add, remove, and contains operations with average time complexity O(1).
Implemented as a hash table.


TreeSet:

Maintains the order of elements in sorted order.
Offers fast add, remove, and contains operations with average time complexity O(log n).
Implemented as a tree data structure.


LinkedHashSet:

Maintains the order of elements in which they were inserted.
Offers fast add, remove, and contains operations with average time complexity O(1).
Implemented as a hash table with doubly-linked list.

In general, you would choose a HashSet if you don't care about the order of elements, but you need fast add, remove, and contains operations. You would choose a TreeSet if you need to maintain the order of elements in sorted order, but you are okay with slightly slower add, remove, and contains operations. You would choose a LinkedHashSet if you need to maintain the order of elements in the order in which they were inserted, and you need fast add, remove, and contains operations.


note:
The order of elements in a LinkedHashSet can be useful in certain situations where the order of elements is important. Here are a few examples:

Cache implementation: The order of elements in a LinkedHashSet can be used to implement a cache that removes the least recently used (LRU) items first. By adding new elements to the end of the linked list, and removing the least recently used elements from the beginning, the cache can be kept to a maximum size.

Preserving the order of elements in a sequence: If you need to maintain the order of elements in a sequence, such as in a history list or a list of recently visited pages, a LinkedHashSet can be used to store the elements in the order in which they were added.

Debugging and testing: If you need to inspect the order of elements in a collection, a LinkedHashSet can be useful. The order of elements in a LinkedHashSet provides a clear picture of the order in which elements were added to the set.

Overall, the order of elements in a LinkedHashSet can be useful in situations where the order of elements is important and you need to maintain the order of elements in the order in which they were added

---------------------------------------------------------------------------------------------------------------
HashTable

its a class it implements map interface
hashtable is an associate array where in the values are stored as keyvalue pair.use Hashing/hasing funtion to define the
index of the keyvalue value pair.
its synchronised.to avoid collision in hastable we can use list.it will stored value with same value.allow duplocate value  not suport null value

In Java, hash tables are implemented using the java.util.HashMap class. The HashMap class uses a hash table internally to store key-value pairs.

Here's a high-level overview of how it works:

The hash function is used to map the key to an array index.
The key-value pair is stored at the calculated index in the array.
When retrieving a value for a key, the hash function is used to calculate the index again, and the corresponding value is returned.
To handle collisions (when multiple keys map to the same index), HashMap uses a technique called separate chaining, where each index in the array is linked to a linked list of key-value pairs.

The size of the array used by the hash table is determined by the initial capacity and the load factor. The load factor determines the maximum allowed ratio of stored key-value pairs to the size of the array. When the load factor exceeds a certain threshold, the hash table is automatically resized to accommodate more key-value pairs.

1.synchronised
2.it does not allow null key or null value.

How its works internally

when we store ht.put("naveen",200); initially memorry will spilit into 11 segment which means 11 indexes 
hash("naveen") -> hascode % 11 = 4 so this will stored in 4 th index
hash("rahul") -> hascode % 11 = 6 so this will stored in 6 th index
hash("praveen") -> hascode % 11 = 4 so this will stored in 4 th index but collision happened it will create node under same 4th index and store again any hash code has 4 as value it will create one more node under praveen node and store(link list)

And for getting ht.get("naveen")  hash("naveen") -> hascode % 11 = 4 . so in 4 th index we have other node also so next it will compare the naveen hashcode with help of equals method and return 200

we can use debugger mode to check whether it create 11 segment and where its store

import java.util.Hashtable;

public class HashtableExample {
  public static void main(String[] args) {
    // Creating a Hashtable
    Hashtable<String, Integer> hashtable = new Hashtable<>();

    // Adding Key-Value pairs to a Hashtable
    hashtable.put("Key1", 1);
    hashtable.put("Key2", 2);
    hashtable.put("Key3", 3);

    // Retrieving a value using a key
    int value = hashtable.get("Key2");
    System.out.println("Value for key 'Key2': " + value);
  }
}

note;
package practiseJavaProb;

import java.util.HashMap;
import java.util.Hashtable;



public class Main {
  public static void main(String[] args) {
    // Creating a HashMap
	  Hashtable<String, Integer> map = new Hashtable<>();

    // Adding Key-Value pairs to a HashMap
    map.put("Key1", 1);
    map.put("Key2", 3);
    map.put(null, null);

    // Retrieving a value using a key
    int value = map.get("key2");
    System.out.println("Value for key 'Key2': " + value);
  }
}
throw error

The code you posted throws a NullPointerException because you're trying to insert a null key into a Hashtable, which is not allowed. According to the Java documentation, Hashtable does not allow null keys or values. If you try to insert a null key or value, a NullPointerException will be thrown.

To avoid the exception, you can simply remove the line where you're trying to insert the null key:

Hashtable<String, Integer> map = new Hashtable<>();

// Adding Key-Value pairs to a HashMap
map.put("Key1", 1);
map.put("Key2", 3);

// Retrieving a value using a key
int value = map.get("Key2");
System.out.println("Value for key 'Key2': " + value);

-----------------------------------------------------------------------------------

HashMap
its uses hastable internally.it store  the value as the keyvalue pair.using hasing technique and 
inject the data into data base its also internally uses hastable to store the value as keyvalue pair its not synchronised.Can store
duplicate value not key.we use put method to insertion
HashMap allows only one null Key and lots of null values.
unique key

HashMap is a class in Java that implements the Map interface. It stores key-value pairs and provides constant-time O(1) complexity for the basic operations, such as get and put.

A HashMap is a dynamic data structure that automatically increases its size as the number of elements stored in it grows. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.

when we store ht.put("naveen",200); initially memorry will spilit into 16 segment which means 16 indexes 
hash("naveen") -> hascode % 11 = 4 so this will stored in 4 th index
hash("rahul") -> hascode % 11 = 6 so this will stored in 6 th index
hash("praveen") -> hascode % 11 = 4 so this will stored in 4 th index but collision happened it will create node under same 4th index and store again any hash code has 4 as value it will create one more node under praveen node and store(link list)

And for getting ht.get("naveen")  hash("naveen") -> hascode % 11 = 4 . so in 4 th index we have other node also so next it will compare the naveen hashcode with help of equals method and return 200

we can use debugger mode to check whether it create 11 segment and where its store

import java.util.HashMap;

public class HashMapExample {
  public static void main(String[] args) {
    // Creating a HashMap
    HashMap<String, Integer> map = new HashMap<>();

    // Adding Key-Value pairs to a HashMap
    map.put("Key1", 1);
    map.put("Key2", 2);
    map.put("Key3", 3);

    // Retrieving a value using a key
    int value = map.get("Key2");
    System.out.println("Value for key 'Key2': " + value);
  }
}

note
public class Main {
  public static void main(String[] args) {
    // Creating a HashMap
    HashMap<String, Integer> map = new HashMap<>();

    // Adding Key-Value pairs to a HashMap
    map.put("Key1", 1);
    map.put("Key2", 3);
    map.put(null, null);

    // Retrieving a value using a key
    int value = map.get(null);
    System.out.println("Value for key 'Key2': " + value);
  }
}

throw error

The code you posted throws a NullPointerException because you're trying to retrieve the value associated with a null key, which is not allowed in a HashMap. According to the Java documentation, null is allowed as a key or value in a HashMap, but it's important to handle them properly to avoid NullPointerExceptions.

In this case, you can use a null check to ensure that the value you're trying to retrieve is not null:

int value = map.get(null);
if (value != null) {
  System.out.println("Value for key 'null': " + value);
} else {
  System.out.println("Value for key 'null' not found.");
}

=================================================================================================================================================
9.Big O Notation

The big O notation is used to describe the time complexity of an algorithm, which is the amount of time it takes for the algorithm to complete as a function of the size of the input.

The big O notation describes the upper bound on the growth rate of the running time of an algorithm, so it's an approximation of the worst-case time complexity. The big O notation uses the symbol O(f(n)), where f(n) is a function that describes the growth rate of the running time as a function of the size of the input n.

Here are some common time complexities expressed using big O notation:

O(1) - Constant time: The running time of the algorithm is independent of the size of the input.

O(log n) - Logarithmic time: The running time of the algorithm increases logarithmically with the size of the input.

O(n) - Linear time: The running time of the algorithm increases linearly with the size of the input.

O(n log n) - Log-linear time: The running time of the algorithm increases as the size of the input times the logarithm of the size of the input.

O(n^2) - Quadratic time: The running time of the algorithm increases as the square of the size of the input.

O(2^n) - Exponential time: The running time of the algorithm grows exponentially with the size of the input.

It's important to note that the big O notation is an upper bound, so the actual running time of an algorithm might be faster than the time complexity expressed using big O notation. However, the big O notation provides a useful approximation of the worst-case time complexity, and it's a common way to compare the relative efficiencies of different algorithms.

=================================================================================================================================================
10.
Regular expression

A regular expression in Java is a sequence of characters that defines a search pattern. It's a way of matching text in a more flexible and concise manner, as compared to using string methods such as indexOf() and matches(). Regular expressions are used in Java through the java.util.regex package and its classes such as Pattern and Matcher. They can be used to search, edit, and manipulate strings, validate input, and more.

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {
  public static void main(String[] args) {
    String text = "Hello, world!";
    String pattern = "world";

    // Compile the regular expression pattern
    Pattern p = Pattern.compile(pattern);

    // Get a Matcher object
    Matcher m = p.matcher(text);

    // Check if the pattern is found in the text
    if (m.find()) {
      System.out.println("Found pattern in the text");
    } else {
      System.out.println("Pattern not found in the text");
    }
  }
}


import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {
  public static void main(String[] args) {
    String email = "example@domain.com";
    String pattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";

    // Compile the regular expression pattern
    Pattern p = Pattern.compile(pattern);

    // Get a Matcher object
    Matcher m = p.matcher(email);

    // Check if the email address is valid
    if (m.matches()) {
      System.out.println("Valid email address");
    } else {
      System.out.println("Invalid email address");
    }
  }
}

In this example, the regular expression "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$" is used to validate the email address. The output of the program will be "Valid email address". Note that this is just a simple example and there are more advanced regular expressions for email validation.


==========================================================================================================================================
11.

Cloning --->

the process of creating replica of perticular obj by copying one object completly into another object.
we have to implement clonable interface. If we do not implement Cloneable interface, clone() method generates CloneNotSupportedException.
if we need to use many object having the same data, then don't create objects using new keyword. use clone method to create that object,
because operation of creating object with clone method is faster than using new keyword

Cloning in Java refers to creating a copy of an object. There are two ways to achieve this in Java: shallow cloning and deep cloning.

Shallow cloning creates a new instance of an object, but it only copies its reference to the object's attributes, rather than copying the attributes themselves. This means that the original object and its clone will share the same attributes.

Here is an example of shallow cloning in Java:

class MyClass implements Cloneable {
  int x;

  public Object clone() throws CloneNotSupportedException {
    return super.clone();
  }
}

public class Main {
  public static void main(String[] args) {
    MyClass obj1 = new MyClass();
    obj1.x = 5;

    try {
      MyClass obj2 = (MyClass) obj1.clone();
      System.out.println("obj2.x = " + obj2.x);
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
}


In this example, the MyClass class implements the Cloneable interface, which allows it to be cloned. The clone() method is then overridden to return a shallow copy of the object.

Deep cloning, on the other hand, creates a new instance of an object and also creates new instances of all its attributes. The original object and its clone are completely independent of each other.

Here is an example of deep cloning in Java:

class MyClass implements Cloneable {
  int x;

  public Object clone() throws CloneNotSupportedException {
    MyClass clone = (MyClass) super.clone();
    clone.x = this.x;
    return clone;
  }
}

public class Main {
  public static void main(String[] args) {
    MyClass obj1 = new MyClass();
    obj1.x = 5;

    try {
      MyClass obj2 = (MyClass) obj1.clone();
      System.out.println("obj2.x = " + obj2.x);
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
}


In this example, the clone() method is overridden to create a deep copy of the object, by also creating a new instance of the x attribute. The output of the program will be "obj2.x = 5".


Cloning can be useful in a number of scenarios in Java programming. Here are a few examples:

Creating independent copies: Cloning can be used to create independent copies of an object, which can be modified without affecting the original object.

Improving performance: Cloning can be used to improve the performance of a program, by creating a new instance of an object that has already been constructed, rather than constructing a new object from scratch.

Object pooling: Cloning can be used in object pooling, where a pool of objects is created and objects are borrowed from the pool, used, and then returned. Cloning can be used to create new instances of objects in the pool, without having to construct them from scratch.

Testing: Cloning can be used in testing, where a test case needs to modify an object without affecting other test cases. By creating a clone of the object, the original object can be preserved for other test cases, while the clone can be modified for the current test case.

Implementing prototypes: Cloning can be used to implement the prototype pattern, where an existing object is cloned to create a new instance, which can then be modified as needed. This can be a more efficient way to create objects, compared to constructing objects from scratch.


================================================================================================================================
12.

Tokenizer

A tokenizer in Java is a utility class that is used to split a string into smaller units called tokens. Tokens are usually defined as sequences of characters separated by a delimiter, such as a space, a comma, or a tab.

Tokenizers are useful in a variety of scenarios, such as:

Parsing strings: Tokenizers can be used to parse strings that contain structured data, such as CSV files, log files, or configuration files.

Processing command-line arguments: Tokenizers can be used to process command-line arguments passed to a program.

Text processing: Tokenizers can be used to split text into words, sentences, or paragraphs, which can then be processed further.

import java.util.StringTokenizer;

public class Main {
  public static void main(String[] args) {
    String str = "This is a string";
    StringTokenizer tokenizer = new StringTokenizer(str);

    while (tokenizer.hasMoreTokens()) {
      System.out.println(tokenizer.nextToken());
    }
  }
}

public class Main {
  public static void main(String[] args) {
    String str = "This is a string";
    String[] tokens = str.split(" ");

    for (String token : tokens) {
      System.out.println(token);
    }
  }
}

Note that the StringTokenizer class is considered to be outdated, and it is recommended to use the split() method of the String class or regular expressions instead


================================================================================================================================
13.

Enum

The Enum in Java is a data type which contains a fixed set of constants.naming conventions should have all constants in capital 
letters.Enums are used to create our own data type.for instance we can create enum for month.
Java Enum internally inherits the Enum class, so it cannot inherit any other class, but it can implement many interfaces.
We can have fields, constructors, methods, and main methods in Java enum.we use enum keyword.

public enum Days {
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  THURSDAY,
  FRIDAY,
  SATURDAY,
  SUNDAY
}

public class Main {
  public static void main(String[] args) {
    Days day = Days.FRIDAY;
    System.out.println("Today is " + day);
  }
}

================================================================================================================================
14.

Wrapper class

In Java, a wrapper class is a class that wraps (or encases) a primitive data type, converting it to an object. The eight primitive data types in Java (boolean, byte, char, short, int, long, float, and double) are not objects, so they cannot be manipulated as objects. Wrapper classes allow you to work with primitive data types as objects, giving you more flexibility when working with them.

Here's an example of using a wrapper class:
public class Main {
  public static void main(String[] args) {
    int primitiveInt = 42;
    Integer wrapperInt = Integer.valueOf(primitiveInt);

    System.out.println("Primitive int: " + primitiveInt);
    System.out.println("Wrapper int: " + wrapperInt);
  }
}

In this example, we've created a primitive integer with the value 42 and a Integer wrapper object with the value of that primitive integer. The output of this program would be:

Here are some examples of when wrapper classes are needed:

When you need to pass a primitive data type to a method that takes an object as a parameter: Since primitive data types are not objects, you cannot pass them directly to methods that take objects as parameters. By wrapping a primitive data type in a wrapper class, you can pass the object to the method instead.

When you need to store primitive data types in a data structure that only stores objects: Data structures such as lists and maps can only store objects, not primitive data types. By wrapping a primitive data type in a wrapper class, you can store it in a data structure that only stores objects.

When you need to manipulate primitive data types as objects: Wrapper classes provide methods that you can use to manipulate primitive data types, such as converting them to strings or comparing them to other objects.

These are just a few examples of when wrapper classes are needed in Java. By wrapping primitive data types in wrapper classes, you can use the full power of the object-oriented features of the Java language to manipulate and work with primitive data types.

Java collection framework, like List or Set, is designed to work with objects, not primitive data types. Wrapper classes, such as Integer, Double, etc., are used to represent the corresponding primitive data types as objects. This allows the collections to store objects instead of just primitive types, making it more versatile and flexible. Additionally, the use of wrapper classes provides an easy way to use the collection's built-in methods and functions, such as sorting, searching, etc. In short, wrapper classes are used in collections to maintain consistency and provide functionality that is not available with primitive data types.


================================================================================================================================
15.

Finalize

finalise is the method present inside object class.
garbage collector call  finalise method to clean up activities before obj is destroyed. its a automatic process.every time we run
a program jvm do it.

The finalize() method in Java is a method defined in the Object class. It is called by the garbage collector when it determines that an object is no longer reachable, allowing the object to perform any cleanup necessary before it is destroyed. The finalize() method has the following signature:



protected void finalize() throws Throwable 
It's important to note that the finalize() method is not guaranteed to be called, and even if it is called, it's not guaranteed to be called in a timely manner. Additionally, the finalize() method should not be used as a substitute for proper resource management. Instead, resources should be explicitly closed when they are no longer needed.

In practice, the use of the finalize() method is discouraged in favor of other resource management techniques, such as the try-finally block or the try-with-resources statement, both of which offer more predictable and reliable resource management.


================================================================================================================================
16.

multi Thread in Java

A multi-threaded program in Java is a program that has multiple threads of execution, each running in parallel and performing a different task. This allows a program to perform multiple tasks concurrently, improving its efficiency and responsiveness.

Here's a simple example that demonstrates how to create a multi-threaded program in Java using the Thread class:



multitasking done at programming level is called as threads.main purpose of the thread is to improve the perfomence of the application
and reducing execution time.it should not be  depending on other thread .two way we can buil thread .one is extending the thread second
implement runnable interface.synchronisation will be followed when thread are operating comman data.sleep method notify method and 
wait method will be used when one thread depending on other data.
ex: Railway ticket reservation system where multiple customers accessing the server. 
main purpose of multithreading is to provide simultaneous execution of two or more parts of a program to maximum utilize the CPU time. ...
Threads are lightweight sub-processes, they share the common memory space


class WorkerThread extends Thread {
   public void run() {
      for (int i = 0; i < 10; i++) {
         System.out.println("Worker thread running: " + i);
      }
   }
}

public class Main {
   public static void main(String[] args) {
      WorkerThread worker = new WorkerThread();
      worker.start();

      for (int i = 0; i < 10; i++) {
         System.out.println("Main thread running: " + i);
      }
   }
}

In this example, we have a worker thread class, WorkerThread, that extends the Thread class and overrides the run() method. This method is executed when the worker thread is started by calling the start() method.


class Worker implements Runnable {
   public void run() {
      for (int i = 0; i < 10; i++) {
         System.out.println("Worker thread running: " + i);
      }
   }
}

public class Main {
   public static void main(String[] args) {
      Worker worker = new Worker();
      Thread workerThread = new Thread(worker);
      workerThread.start();

      for (int i = 0; i < 10; i++) {
         System.out.println("Main thread running: " + i);
      }
   }
}
In this example, we have a worker class, Worker, that implements the Runnable interface and overrides the run() method. The run() method is executed when the worker thread is started.
is to associate the worker object with the Thread object. The worker object is an instance of a class that implements the Runnable interface and contains the code that should be executed by the thread.

By passing the worker object to the Thread constructor, we tell the Thread object to execute the run() method of the worker object when the thread is started. This allows us to separate the code that defines the behavior of the thread (in the worker object) from the code that controls the thread's execution (in the Thread object).

In the main method, we create an instance of the worker class and then create a Thread object and pass the worker instance to its constructor. Finally, we call the start() method to start the worker thread.

In the same way as the previous example, we have a loop that runs 10 times in the main thread, printing a message to the console.

When this program is executed, the worker thread and the main thread run concurrently, and their output is interleaved in the console. This demonstrates how multiple threads can run concurrently in a Java program using the Runnable interface.


The difference between using the Thread class and the Runnable interface in Java for creating multi-threaded programs lies in their design.

The Thread class is a concrete class in Java that extends the Object class and implements the Runnable interface. When you extend the Thread class, you create a new class that is a Thread and must override the run() method to specify the code that the thread should execute.

On the other hand, the Runnable interface is an interface that defines a single run() method. To create a thread using the Runnable interface, you create a class that implements the Runnable interface and overrides the run() method to specify the code that the thread should execute. Then, you create a Thread object and pass an instance of the Runnable class to its constructor.

In terms of functionality, both approaches are equivalent and can be used to create multi-threaded programs in Java. The choice between using the Thread class or the Runnable interface largely depends on personal preference and design considerations. Some developers prefer to extend the Thread class because it provides more control over the thread, while others prefer to use the Runnable interface because it promotes the separation of concerns between the thread's code and the Thread object

--------------------------------------------------------------------------------------------------------------
Threadlifecycle--->
new when we create a object for a thread with new key word its goes to new state.whenever we call the start method on the object.its 
change the state to runnable state.then thread schedular allocate the memmory in cpu to run a thread.in this state thread start 
execute the thread.when we use wait sleep suspend in thread its go to waiting state then notify notify the main thread then
main thread kill the wait state state.after all execution done its goes to dead state its single life cycle of thread.

thread synchronisation--->
when two threads are operating on common data the data might get currupted becouse of multitasking.To make the thread one after
other we use synchronised keyword to make one thread to wait untill other thread complete the task.for example bank balance 
data curruption might happen if we not use synchised concept.


Thread priority--->
it decide which thread is going to run first which thread run first and which one is run later.we set the priority then its a request
made to thread schedular there is no assurity that will be processed and appeal.the minimum thread priority is 1.maximum thread 
priority is 5 however we can set the thread priority with number anything between 1 to 10.


Thread pool--->
collection of thread at one place called thread pool.by using thread pool we can limit the number thread nunning in the program.
 its improve the performence of the application every time request come
its assinged to the thread .once the thread complete the task it will not get destroyed it again use it for other task to execute
we can use exixting thread instead of creatig new thread.
================================================================================================================================
final class 

if we make a class final it cant be extended and some classes erfor standard funtion and they are not meant to be modified .ex string manupulation
final class Circle {
  private double radius;

  public Circle(double radius) {
    this.radius = radius;
  }

  public double getRadius() {
    return radius;
  }

  public double getArea() {
    return Math.PI * radius * radius;
  }
}
In this example, the Circle class is declared as final, meaning that no other class can inherit from it. This can be useful in situations where you want to prevent others from changing the behavior of your class.



================================================================================================================================

Mutable and Immutable--->

Objects in Java are either mutable or immutable. it depends on how the object can be created.

to create immutable class create class as final.2 set the values of the properties using constructor 3.make the members//we cant use setter for final
final.do not use setters and getters method.

An immutable class is a class whose instances cannot be modified once created. Here are some steps to create an immutable class in Java:

Declare the class as final: This ensures that the class cannot be subclassed and its state cannot be altered.

Make all fields private and final: This ensures that the fields cannot be changed once they are set during object construction.

Don't provide setter methods: This means that once an object is created, its state cannot be changed.

Initialize all fields in the constructor: All fields should be initialized in the constructor and not changed later.

Return a new object instead of modifying an existing object: If a method needs to modify an object's state, it should return a new object with the updated state instead of modifying the existing object.

Here's an example of an immutable class in Java:

final class ImmutablePerson {
  private final String name;
  private final int age;

  public ImmutablePerson(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }
}

String is the immutable class
Security: Immutable strings are safer to use in multithreaded environments where multiple threads could potentially modify the same string object. When a string is made immutable, it is guaranteed that its value cannot be changed, making it safer to use in concurrent environments.

Performance: Immutable strings are more efficient in terms of memory and performance because they can be shared between multiple objects. When two string objects have the same value, they can refer to the same underlying character array, rather than having separate copies of the same data. This saves memory and improves performance.

Simplicity: Immutable strings are simpler to use because they do not have to be protected from changes. This makes it easier to write and maintain code that uses strings.

Constant pool--->The area where immutable pbjects are present thats called constand pool


StringBuffer;

String Concatenation: String concatenation is a common operation in programming, and it's more efficient to concatenate immutable strings than mutable strings. When concatenating strings, a new string object is created, and the characters from the original strings are copied into the new string. With mutable strings, the original strings would have to be changed, which is less efficient.


Dynamic String Building: When you need to build up a string dynamically, such as when constructing a SQL query or building a formatted string, StringBuffer can be useful. It allows you to append, insert, delete, and replace characters in the sequence, making it easier to construct strings programmatically.

Performance: StringBuffer is more efficient than string concatenation for constructing strings, especially when building strings in a loop. With StringBuffer, the characters are appended to the buffer, and the buffer is converted to a string only when it's needed.

Thread-Safety: StringBuffer is thread-safe, meaning that multiple threads can safely access the same StringBuffer object. This is important when building strings in a multithreaded environment.

Text Processing: When you need to perform text processing tasks, such as replacing substrings, splitting strings, or converting strings to different formats, StringBuffer can be a useful tool.

String manipulation in Servlets: StringBuffer is often used in Servlets for string manipulation, such as building dynamic HTML pages or constructing URLs.

Here are some common use cases for StringBuilder:

Dynamic String Building: StringBuilder is useful for building up strings dynamically, such as when constructing a SQL query or building a formatted string.

Performance: StringBuilder is more efficient than StringBuffer for single-threaded environments because it does not need to synchronize access to the object.

Text Processing: StringBuilder can be used for text processing tasks, such as replacing substrings, splitting strings, or converting strings to different formats.

String manipulation in non-concurrent Applications: StringBuilder is often used in non-concurrent applications, such as desktop applications or single-threaded servlets, for string manipulation tasks.
================================================================================================================================
Throw--->we can create custom exception using throw key word.its throw exception object to catch method.
throw keyword is used to throw an exception explicitly. It can throw only one exception at a time.

public void divide(int dividend, int divisor) {
    if (divisor == 0) {
        throw new ArithmeticException("Cannot divide by zero");
    }
    int result = dividend / divisor;
    System.out.println("Result is: " + result);
}


Thrown--->
It is used when the function has some statements that can lead to some exceptions.by using throws key keyword in method.
exception thrown to the method calling statement.In method we have to use try catch.
but by using thrown in class defining line exception will be handled by the jvm.(jvm called main)
throws keyword can be used to declare multiple exceptions, separated by comma. Whichever exception occurs, 
if matched with the declared ones, is thrown automatically then.

public void readFile(String fileName) throws IOException {
    File file = new File(fileName);
    BufferedReader br = new BufferedReader(new FileReader(file));
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
}

================================================================================================================================

Finally--->
finally is associated with try cathch block.any code we written in finally block regardless of exception happen or not
it will run.its exctence of catch,try.


Final--->
we can use final keyword to class method and variables.//we cant reinitialise the variable again.
final in  variables -to make variable constand
final in class- to prevent not to inherit to other
final in method- to prevetn overriding.

JDBC--->
To establish connection between javaapp and mysql we need sql driver it has class drivermanager with method get connection
to create connection.then send a query we need to create statement object.it will send  a query to sqlDb and the query method
will return Result in Result set obj.we can db operation.

Serialisation--->
Serialisation is the process of storing object in byte state permanently in the file system.we store  the object we use Fileout
putstreatm constructor  to access the path of the file and we use objectoutPutStream to send the object to systemfiles.


deserialisation--->
In deserialisation we convert the byte state of object from file and can read that object is called deserialisation
To do thid we use fileinputstream constructor to access the file and also we use objectInputstream constructor to retrive
the object and access the file then by using readobject() method it will return the obj by reading that byte formate
Aa2=(A) ois.readobject().we typecast to store the object in perticular class.


Serialization and deserialization are mechanisms in Java that allow objects to be written to and read from a stream. Serialization is the process of converting an object's state to a stream of bytes, while deserialization is the process of creating an object from a stream of bytes.

The Java Serialization API provides a standard mechanism for converting objects to and from a stream of bytes. To make an object serializable, it must implement the java.io.Serializable interface. Once an object is serializable, it can be written to a stream using an ObjectOutputStream and read from a stream using an ObjectInputStream.

Here is an example of how serialization and deserialization can be used in Java:

public static void main(String[] args) {
    Employee employee = new Employee("John Doe", 35, 10000);

    // Serialization
    try (FileOutputStream fos = new FileOutputStream("employee.ser");
         ObjectOutputStream oos = new ObjectOutputStream(fos)) {
        oos.writeObject(employee);
    } catch (IOException ex) {
        System.out.println("An error occurred while serializing the object: " + ex.getMessage());
    }

    // Deserialization
    try (FileInputStream fis = new FileInputStream("employee.ser");
         ObjectInputStream ois = new ObjectInputStream(fis)) {
        Employee deserializedEmployee = (Employee) ois.readObject();
        System.out.println("Deserialized Employee: " + deserializedEmployee);
    } catch (IOException | ClassNotFoundException ex) {
        System.out.println("An error occurred while deserializing the object: " + ex.getMessage());
    }
}


In this example, an Employee object is created and then serialized to a file named employee.ser using an ObjectOutputStream. The Employee class must implement the Serializable interface to be serializable.

The Employee object can then be deserialized from the file using an ObjectInputStream and cast to an Employee object. The deserialized object can be used just like any other object in the program.

Note that the try-with-resources statement is used in this example to ensure that the streams are properly closed even if an exception is thrown during the serialization or deserialization process.
================================================================================================================================


Fileconcept--->The File class have several methods for working with directories and files such as creating new directories or files, deleting and renaming directories or files, listing the contents of a directory etc.



using file class constructor  we can check the file is present or not using f.exit method.it will return boolean value
delete() method is used for delete the file that present in the path and return boolean value
File file = new File("newfile.txt");
if (file.delete()) {
  System.out.println("File deleted: " + file.getName());
} else {
  System.out.println("Failed to delete file: " + file.getName());
}

create() we can create the file in the given path.
File file = new File("newfile.txt");
try {
  file.createNewFile();
  System.out.println("File created: " + file.getName());
} catch (IOException ex) {
  System.out.println("An error occurred while creating the file: " + ex.getMessage());
}

Rename file
File oldFile = new File("oldfile.txt");
File newFile = new File("newfile.txt");
if (oldFile.renameTo(newFile)) {
  System.out.println("File renamed from " + oldFile.getName() + " to " + newFile.getName());
} else {
  System.out.println("Failed to rename file " + oldFile.getName());
}

File exists
File file = new File("newfile.txt");
if (file.exists()) {
  System.out.println("File exists: " + file.getName());
} else {
  System.out.println("File does not exist: " + file.getName());
}



mkdir() will create folder in path and return boolean value .
File directory = new File("newdirectory");
if (directory.mkdir()) {
  System.out.println("Directory created: " + directory.getName());
} else {
  System.out.println("Failed to create directory: " + directory.getName());
}


import java.io.File;

public class Main {
  public static void main(String[] args) {
    String path = "/path/to/directory";
    File directory = new File(path);
    boolean success = directory.mkdir();

    if (success) {
      System.out.println("Directory created successfully");
    } else {
      System.out.println("Directory creation failed");
    }
  }
}



list() it wiill return all folder in given path.
import java.io.File;

public class Main {
  public static void main(String[] args) {
    String path = "/path/to/directory";
    File directory = new File(path);

    File[] subdirectories = directory.listFiles(File::isDirectory);
    for (File subdirectory : subdirectories) {
      System.out.println(subdirectory.getName());
    }
  }
}
In this example, the listFiles(File::isDirectory) method is used to only get the subdirectories. The File::isDirectory is a method reference that returns true if a File object represents a directory, and false otherwise.



fileReader class is used read the file in given path by useing read() and this method will return single char onlu
creating a for loop we can read the file.
File file = new File("newfile.txt");
try (FileReader reader = new FileReader(file)) {
  int data = reader.read();
  while (data != -1) {
    System.out.print((char) data);
    data = reader.read();
  }
  System.out.println("\nData read from file: " + file.getName());
} catch (IOException ex) {
  System.out.println("An error occurred while reading from the file: " + ex.getMessage());
}


filewriter class used to write the content in given path by using write mehtod.flush() give assurity that no bug
will happen in while writing the content. it means to clear the stream of any element that may be or maybe not inside the stream.
File file = new File("newfile.txt");
try (FileWriter writer = new FileWriter(file)) {
  writer.write("Hello, World!");
  System.out.println("Data written to file: " + file.getName());
} catch (IOException ex) {
  System.out.println("An error occurred while writing to the file: " + ex.getMessage());
}
================================================================================================================================


bubble sort---> bubble sort is an algorithm that sort the values by comparing adjucent elements and swapping them
if they appear in wrong order.for example if the array has 5 elements we have to iterate  5 times.in fisrt iteration we
have to compare every element.so first iteration itsself max or min value sort to the end or firstindex
 then second iteration we dont need to compare all element. we can leavve last or first index so next we need to
 compare 4 times so like that untill we reach every item in list order correctly.


 Array--->Java array is an object 
 An array is a collection of items stored at contiguous memory locations.
 This makes it easier to calculate the position of each element by simply adding an offset to a base value(index).
 You canâ€™t change the size once you have declared the array you canâ€™t change its size because of static memory allocation.
 in single array we can store only same type data .
 Arrays allow random access to elements. 
 This makes accessing elements by position faster.
 Used to Implement other data structures like Stacks, Queues, Heaps, Hash tables.
difference between the two indexes is the offset.



2d array--->
2D array can be defined as an array of arrays.represented as the collection of rows and columns
The syntax of declaring two dimensional array is very much similar to that of a one dimensional array.
same application as arry but we have to use column no and index no to access.
2D Arrays are used to implement matrices
int[][] twoDArray = new int[3][3];
int[][] twoDArray = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
int value = twoDArray[1][2]; // value = 6
public class Main {
  public static void main(String[] args) {
    int[][] twoDArray = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    for (int i = 0; i < twoDArray.length; i++) {
      for (int j = 0; j < twoDArray[i].length; j++) {
        System.out.print(twoDArray[i][j] + " ");
      }
      System.out.println();
    }
  }
}




Throwable--->
throwable is the super most class of all errors and exception in java.only object are thrown by jvm.
Throwable class is the root class of Java Exception Heirarchy and is inherited by two subclasses:
1.Exception
2.Error
Throwable contains a snapshot of the execution stack of its thread at the time it was created.
 It can also contain a message string that gives more information about the error. 
 It can also suppress other throwables from being propagated.


 Error--->
indicates the problem that mainly occurs due to the lack of system resourses
There are three kinds of errors: syntax errors, runtime errors, and logic errors. Syntax errors.
 These are errors where the compiler finds something wrong with your program

exception--->
Java provides a mechanism to handle exceptions, so that the program can continue running after an exception is caught, instead of abruptly halting
exception are unexcepted event that hault programs executio aprubtly.exception is cause when bad user input given
to handle exception we can use try catch block.

Here is a list of common runtime exceptions in Java:

ArithmeticException: Occurs when an exceptional arithmetic condition has occurred, such as division by zero.

ArrayIndexOutOfBoundsException: Occurs when an array has been accessed with an index that is outside its bounds.

NullPointerException: Occurs when an application attempts to use null in a case where an object is required.

IllegalArgumentException: Occurs when a method has been passed an illegal or inappropriate argument.

ClassCastException: Occurs when an attempt is made to cast an object to a subclass of which it is not an instance.

NumberFormatException: Occurs when a string cannot be parsed as a number.

IllegalStateException: Occurs when an application tries to perform an operation that is illegal or inappropriate for the current state of an object.

And here is a list of common checked exceptions in Java:

IOException: Occurs when an I/O error occurs.

SQLException: Occurs when an error occurs in a database-related operation.

FileNotFoundException: Occurs when a file cannot be found.

ClassNotFoundException: Occurs when a class cannot be found during loading.

InterruptedException: Occurs when a thread is interrupted while it is waiting, sleeping, or otherwise occupied.

NoSuchMethodException: Occurs when a particular method cannot be found.

NoSuchFieldException: Occurs when a particular field cannot be found.


ScannerClass--->
Scannerclass is used to take user input in java.its connect eith keyinput.
it present in java util package.we can obtain only
obtaining the input of the primitive types like int, double, etc. and strings.
 create an object of the Scanner class and use any of the available methods found in the Scanner class documentation.


AbstractClass--->
abstract class can consist of both comlete and incomplete method. to create abstract method abstract keyword is 
mandatory.we can done partial implimentation
we can create static and non static variable but non static variables are cannot be accessed.
cannot create object for abstract class.(we can create object in other class that inherit the absclass then we can use)
Abstraction is a process of hiding the data implementation details, and showing only functionality to the user. 
not 100% abstraction.
//hiding implement mean people can only see what is the method like interface(like steering of car we cant see internal work)
 but they cant see the implement that we did in class
its opt for interface too they only see what all method there but they cant see what is the logic that write inside the
class//

Interface--->
An interface can consist of only incomplete method only.its optional to use abstract key word to create method
it will automatically consider as a abstract only.incomplete method should be completed otherwise its throw an error.
we can create varibles in interface that all are final and
static. Java doesnâ€™t support multiple inheritance, using interfaces you can achieve multiple inheritance
 One of the uses of the interface is to provide communication. 
Through interface you can specify how you want the methods and fields of a particular type
100% abstraction.

note ;
The choice between using an abstract class or an interface in Java depends on the specific requirements of your project. Here are some common scenarios where you might choose to use an abstract class or an interface:

Abstract Class:

When you want to provide a partial implementation: If you want to provide a default implementation for some or all of the methods that must be implemented by subclasses, an abstract class can be a good choice. For example, you might have an abstract class that provides a default implementation for a set of common methods, and then have several subclasses that override those methods as needed.

When you want to enforce a common behavior: If you want to enforce a common behavior for a set of related classes, you can use an abstract class to define a set of methods that must be implemented in a certain way. For example, you might have an abstract class that defines a set of methods for a database connection, and then have several subclasses that implement those methods for different databases.

Interface:

When you want to define a common interface: If you want to define a common interface for a group of related classes, regardless of their implementation details, an interface can be a good choice. For example, you might have an interface that defines the behavior of a vehicle, and then have several classes that implement that interface for different types of vehicles.

When you want to allow multiple inheritance: If you want to allow a class to inherit behavior from multiple sources, you can use an interface. For example, you might have an interface that defines the behavior of a musical instrument, and then have several classes that implement that interface for different types of musical instruments.

When you want to provide a decoupled implementation: If you want to provide a decoupled implementation for a set of related classes, an interface can be a good choice. For example, you might have an interface that defines the behavior of a payment gateway, and then have several classes that implement that interface for different payment gateways.

In conclusion, the choice between using an abstract class or an interface depends on the specific requirements of your project. Both abstract classes and interfaces have their own uses, and can be used together to provide a flexible and decoupled implementation for a set of related classes.

Encapsulation--->
Binding the data by using mehtod.we use setter and getters method to intialise the data.we make the
variable private . so can avoid the direct access of the data.we can improve the security to the programe.
only using setter and getter method we can change value of variable.setter method would set the value and get 
method return the value that set by the setter.


inheritance--->
By using inheritance we inherit the members of one class to another class.we can use that method in inherited
class.we dont need to write same code for again and again.intention of reuse the member.java doesnt support multiple 
inheritance.

polymorphism--->
develop a feature that take more than one form that is called polymorphism.there is two way can perform
polymorphism.overriding and overloading .
in overloading we inherit the method and modify the logiic of the mehtod in the childclass with a same name.
we can check whether overideing happen or not by using by using override annotation.
overloading - creating mehtod more than one method with the same name with different number of arguments or different
type of arguments.



//disadvange of static method Members are part of class and thus
 remain in memory till application terminates.and can't be ever garbage collected. 
 Using excess of static members sometime predicts that you fail to design your product and trying to cop of with static /procedural programming. 
It denotes that object oriented design is compromised.This can result in memory over flow.cant overide it completly get changed.
while clearing object non static method also get terminated by gc.


Superkeyword--->
using Superkeyword we can access member of parent class.
using Superkeyword we can access static and  non static member both
super keyword cannot be used inside static context.using Superkeyword we can call constructor of parant class 
but calling should be from a child class constructor and also should be very first statement.even if we not use
Superkeyword compiler will automatically place the Superkeyword.it only call no arg constructor of parent class.


IIB(Instance initalation block)--->
iib's executed when object are created number of  time we create an object same number of time iib will called.
iib's are used to initalise all instance variable in once give better readability of the code.we can initalise 
static and non static varible inside iib.
class Circle {
    private double radius;
    
    {
        System.out.println("Instance initializer block is called.");
    }
    
    public Circle(double radius) {
        this.radius = radius;
        System.out.println("Constructor is called.");
    }


SIB(static initalisation block)--->
Sib runs before main method runs it doesnt required any invoking statement.
class MathConstants {
    static final double PI = 3.14159265358979323846;
    
    static {
        System.out.println("MathConstants class is loaded.");
    }
}

postIncrement --->
increment the value by one when next time ahead when see the variable again


preincrement--->
increment the value at the moment we use.


================================================================================================================================
funtional interface--->
interface consist of only only incomplere method in it .


marker interface---->
empty interface called marker  interface.Marker interface is a total blank interface that has no body/data-members/implementation.
A class implements marker interface when required, it is just to "mark"; means it tells the JVM that the particular class is for the purpose of cloning so allow it to clone. This particular class is to Serialize its objects so please allow its objects to get serialized.


feature of java 1.8v--->
Lambda expressions,Static  methods in interface,default keyword we can create complete method in 
interface,Functional Interface,ForEach() method,data and time api(joda api),stream api.



    default methods made possible the functional programming concept. in future  if we want to add funtionality to the all the classes we can write the code in it 
so it doestnt required lot of testing .
    Also adding an method in interface will not made it compulsory for all the classes implementing an interface. Simplified the coding practise
Before Java 8, interfaces could have only abstract methods. The implementation of these methods has to be provided in a separate class. So, if a new method is to be added in an interface, then its implementation code has to be provided in the class implementing the same interface. To overcome this issue, Java 8 has introduced the concept of default methods which allow the interfaces to have methods with implementation without affecting the classes that implement the interface.


this style of programming is to make code more concise, less complex, more predictable, and easier to test compared to the legacy style of coding. Functional programming deals with certain key concepts such as pure function, immutable state,




need objective of java8--->
simplify the programe(less no of code consise and clean code and more maintanable code)
parrellel processosing to compatable with hardwares like multicore processors
get the benifits of funtional programming

================================================================================================================================
Typecasting--->
autoupcasting - converting smaller data type to bigger datatype.int to  long
during upcasting data loss might happen hence the programe throw an error
ex float to long .

explicit downcaste-convert bigger datatype into smaller datatype.during explicit downcasting there are chances that 
data lose might happening. 

class upcasting-child objects address is stored in parent referece variable as shown in example //upcasting is the type casting
Aa1=new B();

clas downcasting parent class object address stored in child class 
B b=(B) new A();
================================================================================================================================
Access specifier--->
private default protected public
if member private only access in same class,if member default access canbe only same class same package,
if member protected only access same class same package different package by inheriting,if it is public 
we can access any class any package.
class access specifiere; if class default cannot be accesd in diff package,id class public access any where in project,
class cannot be private and protected
constructor access specifiers;
if cons private creating object cant be in another class,if constructor default creeating it object cannot be done in another
package,if protected object creation cannot be done in another package default and protected are same
if public we can execute anywhere in project.

================================================================================================================================
Data hiding

if variable made private so that it cannot be accessed in different class that is called data hiding.
Data hiding in Java is a mechanism for protecting the internal state of an object from unauthorized access or modification. It is achieved through the use of access modifiers, such as private, protected, and public.
class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
}

================================================================================================================================

this keyword--->
this key word is the special reference variable that hold object address.this keyword cannot be used in side static method
using this key we can access both static and non static context member of class,if we not use this keyword to use 
nonstatic member then automatically this keyword is append by the compiler as shown in the below ex.but this
will happen only in non static method. we can constructor.but calling statement should be in another constructor.


setters and getters--->
setters are the method using we can intialise the non static variales.
getters will return the value that we set by setters method.


varType in java--->if variable var it store any kind of value in it as shown in below example.it cant be static non
static.var cannot be used in an instance and global variable declaration.
var can be used in a local variable declaration.
We can declare any datatype with the var keyword


constructor--->
its like a method but it cannot return any value.
Constructor should have same name as tht of class,every time object created constructor will be called.
we can create multible constructor with different arguments is called condtructor overloading.


return--->
return will return the data to calling statement in void mehtod return keyword is optional it return contril to 
calling statement.


new--->
it send a request to the class to create object once object created new keyword get the address and store that in reference
variable.


================================================================================================================================


Primitive data types and non-primitive data types are two different types of data structures in Java.

Primitive data types are basic data structures that are built into the Java language and are not objects. Examples of primitive data types include int, float, double, char, and boolean. Primitive data types have a fixed size and can be directly manipulated by the processor.

Non-primitive data types, also known as reference data types, are objects that are stored on the heap rather than the stack. Non-primitive data types include arrays, strings, classes, and interfaces. Unlike primitive data types, non-primitive data types have a dynamic size and cannot be directly manipulated by the processor. Instead, they have methods that can be used to access and manipulate their data.

In summary, primitive data types are simple, fast, and have a fixed size, while non-primitive data types are more complex, slower, and have a dynamic size.

================================================================================================================================

The garbage collector in Java is a system component that automatically frees up memory that is no longer being used by the program.

In Java, objects are dynamically allocated on the heap, and once an object is no longer being used, it becomes eligible for garbage collection. The garbage collector periodically scans the heap, identifies objects that are no longer reachable (i.e., objects that cannot be accessed by the program), and frees up the memory occupied by these objects. This allows the program to continue allocating new objects without having to worry about running out of memory.

The garbage collector runs as a low-priority thread in the background, and its exact behavior is determined by the Java Virtual Machine (JVM) implementation. The JVM is responsible for determining when the garbage collector should run, how long it should run, and which objects should be collected. The exact algorithm used by the JVM for garbage collection can vary, but most implementations use a mark-and-sweep algorithm, where the JVM marks all reachable objects and then frees up the memory occupied by the unmarked objects.

Using the garbage collector helps simplify memory management in Java, as developers do not have to manually manage memory allocation and deallocation. However, it is important to understand the impact of the garbage collector on performance, as it can affect the response time and throughput of the program. To optimize the performance of the garbage collector, it is important to understand its behavior and to design your program to minimize the amount of memory that is used and the frequency with which objects become eligible for garbage collection.
================================================================================================================================
nonstatic variable--->
create inside class outside method with static keyword.
belongs to object 
when object created non static variable is loaded into the object.
Memory is allocated for these variable whenever an object is created

static variable--->
static variable created inside class but outside the method with static keyword
located into class common memmory.
we can access static variable anywhere in the class by using class name.object creation is not required for static member
if the variable need to be access all over the class we can declare that static.Memory is allocated for these variable at the time of loading of the class.

local variable--->
created inside method and should be used in created method only.
Local variables are declared in methods, constructors, or blocks.
out side method we cant use local variable

reference variable--->
object address canbe stored inside  the reference variable.local reference variable created inside method can only Used
only inside the mehtod
 static reference variabl- we can create outside mehtod inside class have global access, static keyword used.
Static reference variable can be shared across different instances of classes and can be used shared data across instances.

 Java--->
The main difference between Java and any other programming language is the unique method in which Java code is executed.
 Unlike compiled languages such as C++, Java is compiled into bytecode which can run on any device with the Java Virtual Machine (JVM). 
 C++, on the other hand, is compiled directly into machine code and therefore, can only run on the same platform in which it was compiled.
Another feature is enormous amount of java class library
Java code compile into .class then interpreted into machine code by jvm or jre
 Java hqs Buildin thread but c dont
 Has automatic garabage collection


 JDK--->
JDK is only used by Java Developers. It consists of  javc jre,jvm.jre consists of jvm and other library to run class file.only user has jvm


 JVM--->
JVM is responsible for executing the java program line by line hence it is also known as interpreter.
it would run a class file that generated by the java compiler



 CLASS--->
class is user define Blue  print. Or factory which creates object.class defines the properties to the objects of method and members.In java Class name should be begin with capital letter and surrounded by curly brace


 OBJECT--->
Object is an real time entity it has a state/attribute (memmbers )identity(name of obj) behaviour.when object is created method and  
Non statics member will loaded into it these are objects state behaviour
Objects provide a structured approach to programming.
ObjectsS aims to implement real-world entities like inheritance, hiding, polymorphism etc in programming.
The main aim of OOP is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function.
Flaw of procedural language the inability to reuse code throughout the program .to overcome this oops came in
Reusability structure secure.

================================================================================================================================


when programe strat execution memory will split into two part stact and heap memory.
Heap
It is created by the Java Virtual Machine when it starts. The memory is used as long as the application is running. Java runtime
uses it to allocate memory to objects and Java Runtime Environment (JRE) classes.
Where obj are created
If we continuously allocate memory and we do not free that memory space after use it may result in memory leakage â€“ memory 
is still being used but not available for other processes.so heap manage by garbage collector its automated process by jvm.


Stack
it maintain lifo.load the method top to bottom .
Its maintenance program execution.methods are.loaded into stack after excution all will be removed and connection also removed( ref)

The stack is a region of memory where function call frames and local variables are stored. Each time a method is called, a new frame is pushed onto the top of the stack to store the method's parameters and local variables. When the method returns, the frame is popped off the stack and the memory is freed. The stack has a limited size and is used to store small, short-lived objects and variables. Access to the stack is fast and efficient, but if too much memory is used, a stack overflow can occur, causing the program to crash.

The heap is a region of memory where objects are dynamically allocated and stored. The heap is used to store objects that are long-lived or required to be shared between multiple methods or threads. The heap has a larger size than the stack, but access to the heap is slower due to the need for garbage collection to reclaim memory that is no longer used.

In Java, primitive data types (such as int, float, double, etc.) are stored on the stack, while objects and arrays are stored on the heap. When a method is called and an object is passed as a parameter, a reference to the object on the heap is passed, rather than the object itself. This allows multiple methods to access the same object and share data, but also increases the likelihood of memory leaks if the references are not properly managed.


================================================================================================================================
what is annotation 

Annotations in Java are special types of metadata that provide information about the code, but have no direct effect on the code itself. They are used to associate metadata with Java elements like classes, methods, fields, and variables. The information contained in annotations can be accessed at runtime using reflection, or used by tools and libraries for various purposes, such as code generation, testing, or debugging.

what are the way to create object

Using the new operator: The most common way to create

Using the Class.forName() method: This method allows you to create an instance of a class by passing its fully-qualified name as a string. For example:

String className = "com.example.MyClass";
Class myClass = Class.forName(className);
MyClass instance = (MyClass) myClass.newInstance();

Using the clone() method
MyClass original = new MyClass();
MyClass copy = (MyClass) original.clone();

FileInputStream fis = new FileInputStream("myfile.ser");
ObjectInputStream ois = new ObjectInputStream(fis);
MyClass obj = (MyClass) ois.readObject();
ois.close();
