1.
A programming paradigm is a fundamental style or approach to writing software. It defines the way in which a programmer thinks about the problem they are trying to solve, and the way in which they express the solution using the programming language.

There are several different programming paradigms, including:

Imperative programming, which focuses on describing a series of steps or operations that a computer should perform to achieve a specific task.
Object-oriented programming, which focuses on modeling software as a collection of interacting objects, each of which represents an instance of a class.
Functional programming, which emphasizes the use of pure functions, immutability, and the avoidance of side effects.
Logical programming, which focuses on representing knowledge and solving problems using logic and logical reasoning.
Procedural programming, which focuses on breaking a problem down into a series of procedures or functions that are called in a specific order to solve the problem.
Each programming paradigm has its own strengths and weaknesses and is better suited to certain types of problems than others. A programmer may choose to use a specific paradigm based on their personal preference, the problem they are trying to solve, or the constraints of the project.


======================================================================================================================================================
2.
Imperative programming in Java is a way of writing code that focuses on describing the steps or operations that a computer should perform to achieve a specific task. It uses statements that change the state of the program and variables can be modified.

Functional programming in Java is a way of writing code that emphasizes the use of pure functions and immutability, it encourages the use of functional constructs like lambda expressions and function composition. The state of the program is not allowed to change and variables are immutable.

In simple words, imperative programming is like giving the computer a set of instructions on what to do, step by step. While functional programming is like giving the computer a set of rules to follow without changing the state of the program.


Imperative Programming:

public static int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

public static void main(String[] args) {
    System.out.println(factorial(5)); // 120
}



Functional Programming:

import java.util.stream.IntStream;

public static int factorial(int n) {
    return IntStream.rangeClosed(1, n)
                    .reduce(1, (x, y) -> x * y);
}

public static void main(String[] args) {
    System.out.println(factorial(5)); // 120
}


======================================================================================================================================================
3.
lambda expression

In Java, lambda expressions are used to define a function that can be passed as an argument to a method or assigned to a variable. They are a concise way of defining a function without having to create a separate class or method.

Here's an example of using a lambda expression in a Java program:


import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        // Define a lambda expression that takes a string and returns its length
        Function<String, Integer> getStringLength = (string) -> string.length();

        // Use the lambda expression
        int length = getStringLength.apply("Hello");
        System.out.println("Length: " + length);
    }
}


In this example, the lambda expression (string) -> string.length() is assigned to a variable of type Function<String, Integer>, which is a functional interface that takes a string and returns an integer. The lambda expression is then used to calculate the length of a string.

Lambda expressions can also be used with other functional interfaces from the java.util.function package, such as Consumer, Predicate, and Supplier, which allow you to perform operations on input, make decisions based on input, and get a value respectively.

Lambda expressions are also used with Stream API, which was introduced in Java 8. It allows to process collections of data in a functional way, by performing operations such as filtering, mapping, and reducing on a stream of elements.



Here are some benefits of using lambda expressions in Java:

Conciseness: Lambda expressions allow you to express a function in a compact and readable form, without having to create a separate class or method. This can make your code more concise and easier to understand.

Increased readability: Because lambda expressions are more concise than traditional anonymous classes, they can make your code more readable and reduce the amount of clutter.

Improved maintainability: Lambda expressions can make your code more maintainable by reducing the amount of boilerplate code and increasing the level of abstraction.

Increased flexibility: Lambda expressions can be used in a variety of situations, such as passing a function as an argument to a method, returning a function as a value, or assigning a function to a variable.

Improved performance: The use of lambda expressions with the Stream API, can improve performance by allowing operations to be performed in parallel on large collections of data.

Functional programming: Lambda expressions are an important part of functional programming, it allows to create more expressive and elegant code with fewer lines of code.

In short, lambda expressions provide a more concise and readable way of defining a function, they can be used in a variety of situations, and can make your code more maintainable and performant.

======================================================================================================================================================
4.Inner classes in Java

There are four types of inner classes in Java:
Member Inner Class
Local Inner Class:
Anonymous Inner Class
Static Inner Class

Member Inner Class: A member inner class is defined inside another class, and it has access to all of the members of the outer class, including private members.
// Java Program to Demonstrate Nested class 
 
// Class 1
// Helper classes
class Outer {
 
    // Class 2
    // Simple nested inner class
    class Inner {
 
        // show() method of inner class
        public void show()
        {
 
            // Print statement
            System.out.println("In a nested class method");
        }
    }
}
 
// Class 2
// Main class
class Main {
 
    // Main driver method
    public static void main(String[] args)
    {
 
        // Note how inner class object is created inside
        // main()
        Outer.Inner in = new Outer().new Inner();
 
        // Calling show() method over above object created
        in.show();
    }
}



We can not have a static method in a nested inner class because an inner class is implicitly associated with an object of its outer class so it cannot define any static method for itself. For example, the following program doesnâ€™t compile. But Since JAVA Version 16 we can have static members in our inner class also.
// Class 1
// Outer class
class Outer {
 
    // Method defined inside outer class
    void outerMethod()
    {
 
        // Print statement
        System.out.println("inside outerMethod");
    }
 
    // Class 2
    // Inner class
    class Inner {
 
        // Main driver method
        public static void main(String[] args)
        {
 
            // Display message for better readability
            System.out.println("inside inner class Method");
        }
    }
}

------------------------------------------------------------------------------------------------------

Local Inner Class: A local inner class is defined inside a method, and it has access to all of the members of the outer class, including private members.

class Outer {
   void outerMethod() {
      final int x=98;
      System.out.println("inside outerMethod");
      class Inner {
         void innerMethod() {
            System.out.println("x = "+x);
         }
      }
      Inner y = new Inner();
      y.innerMethod();
   }
}
class MethodLocalVariableDemo {
    public static void main(String[] args){
      Outer x = new Outer();
      x.outerMethod();
    }
}



// declared within a method of outer class
 
// Class 1
// Outer class
class Outer {
 
    // Method inside outer class
    void outerMethod()
    {
 
        // Print statement
        System.out.println("inside outerMethod");
 
        // Class 2
        // Inner class
        // It is local to outerMethod()
        class Inner {
 
            // Method defined inside inner class
            void innerMethod()
            {
 
                // Print statement whenever inner class is
                // called
                System.out.println("inside innerMethod");
            }
        }
 
        // Creating object of inner class
        Inner y = new Inner();
 
        // Calling over method defined inside it
        y.innerMethod();
    }
}
 
// Class 3
// Main class
class GFG {
 
    // Main driver method
    public static void main(String[] args)
    {
 
        // Creating object of outer class inside main()
        // method
        Outer x = new Outer();
 
        // Calling over the same method
        // as we did for inner class above
        x.outerMethod();
    }
}


----------------------------------------------------------------------------------------------------------------


Anonymous Inner Class: An anonymous inner class is defined and instantiated in a single statement, and it cannot have a name. It's commonly used as a method argument.

Anonymous inner classes are declared without any name at all. They are created in two ways. 

As a subclass of the specified type
As an implementer of the specified interface


// Declaration Without any Name 
// As a subclass of the specified type
 
// Importing required classes
import java.util.*;
 
// Class 1
// Helper class
class Demo {
 
    // Method of helper class
    void show()
    {
        // Print statement
        System.out.println(
            "i am in show method of super class");
    }
}
 
// Class 2
// Main class
class Flavor1Demo {
 
    //  An anonymous class with Demo as base class
    static Demo d = new Demo() {
        // Method 1
        // show() method
        void show()
        {
            // Calling method show() via super keyword
            // which refers to parent class
            super.show();
 
            // Print statement
            System.out.println("i am in Flavor1Demo class");
        }
    };
 
    // Method 2
    // Main driver method
    public static void main(String[] args)
    {
        // Calling show() method inside main() method
        d.show();
    }
}




// Declaration Without Any Name
// As an implementer of Specified interface
 
// Interface
interface Hello {
 
    // Method defined inside interface
    void show();
}
 
// Main class
class GFG {
 
    // Class implementing interface
    static Hello h = new Hello() {
       
        // Method 1
        // show() method inside main class
        public void show()
        {
            // Print statement
            System.out.println("i am in anonymous class");
        }
    };
 
    // Method 2
    // Main driver method
    public static void main(String[] args)
    {
        // Calling show() method inside main() method
        h.show();
    }
}





----------------------------------------------------------------------------------------------------------------

Static Inner Class: A static inner class is defined inside another class, but it does not have access to the instance variables of the outer class. It can be used as a top-level class.
Static nested classes are not technically inner classes. They are like a static member of outer class. 


// Importing required classes
import java.util.*;
 
// Class 1
// Outer class
class Outer {
 
    // Method
    private static void outerMethod()
    {
 
        // Print statement
        System.out.println("inside outerMethod");
    }
 
    // Class 2
    // Static inner class
    static class Inner {
 
        public static void display()
        {
 
            // Print statement
            System.out.println("inside inner class Method");
 
            // Calling method inside main() method
            outerMethod();
        }
    }
}
 
// Class 3
// Main class
class GFG {
 
    // Main driver method
    public static void main(String args[])
    {
 
        // Calling method static display method rather than an instance of that class.
        Outer.Inner.display();
    }
}
}

There are certain advantages associated with inner classes are as follows:

Making code clean and readable.
Private methods of the outer class can be accessed, so bringing a new dimension and making it closer to the real world.
Optimizing the code module.

================================================================================================================================================================

5.comparator

A comparator in Java is an interface (java.util.Comparator) that defines a method int compare(T o1, T o2) which compares two objects of the same type and returns an integer value indicating their order. The comparator is used to sort a collection of objects in a custom order defined by the implementer of the interface.

Here is an example of a comparator that compares two strings based on their length:

import java.util.Comparator;

public class StringLengthComparator implements Comparator<String> {
  @Override
  public int compare(String s1, String s2) {
    return Integer.compare(s1.length(), s2.length());
  }
}

This comparator can be used to sort a list of strings in ascending order of their length, like this:

List<String> list = Arrays.asList("dog", "cat", "elephant", "giraffe");
Collections.sort(list, new StringLengthComparator());
System.out.println(list);

This will print [dog, cat, giraffe, elephant]


another ex:

import java.util.Comparator;

public class Employee {
  private String name;
  private double salary;

  public Employee(String name, double salary) {
    this.name = name;
    this.salary = salary;
  }

  public String getName() {
    return name;
  }

  public double getSalary() {
    return salary;
  }

  @Override
  public String toString() {
    return name + ": $" + salary;
  }
}

public class EmployeeSalaryComparator implements Comparator<Employee> {
  @Override
  public int compare(Employee e1, Employee e2) {
    return Double.compare(e1.getSalary(), e2.getSalary());
  }
}


List<Employee> employees = Arrays.asList(
    new Employee("John Doe", 75000),
    new Employee("Jane Doe", 80000),
    new Employee("Bob Smith", 65000)
);
Collections.sort(employees, new EmployeeSalaryComparator());
System.out.println(employees);


This will print [Bob Smith: $65000.0, John Doe: $75000.0, Jane Doe: $80000.0].


=========================================================================================================================================================
